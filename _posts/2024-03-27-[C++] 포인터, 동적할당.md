---
title: "[C++] 포인터, 동적 할당"
date: 2024-03-27
author: Tigger
categories: [C++]
tags: [포인터, 동적 할당, 레퍼런스, placement new]
---

## 개념 
+ 포인터
  + 주소를 저장하는 변수
+ 동적할당
  + 힙 영역에 메모리를 할당하고 주소를 반환함

## 특징
+ 포인터
  + **포인터 자체의 크기**는 플랫폼 bit 수에 대응해서 바뀜
  + 아무것도 가리키지 않는다는 의미로 nullptr를 사용
    + **0, NULL, nullptr 모두 같은 0**이지만 정수를 파라미터로 가진 오버로딩된 함수가 호출되는 경우를 방지하기 위해 nullptr를 사용
  + const 포인터
    + const 키워드가 애스터리스크 뒤에 있다면 주소가 상수화 됨
    + const 키워드가 애스터리스크 앞에 있다면 역참조의 값이 상수화 됨
  + 레퍼런스와의 용도 차이
	+ 포인터
		+ **가리키는 대상의 변경 가능성이 있을 때**
	+ 레퍼런스
		+ **가리키는 대상 자체의 변경 가능성이 없을 때**
		+ **복사 비용 없이 함수를 호출**하고 싶을 때
		+ **함수 내의 값 변경을 유지**하고 싶을 때
+ 동적할당
  + **new, new[]**로 할당
    + 메모리가 부족한 경우 동적 할당이 실패하여 nulptr를 리턴할 수도 있음
    + c언어의 malloc, calloc, realloc와는 다르게 생성자를 호출해줌
  + **delete, delete[]**로 직접 해제
    + c언어의 free와는 다르게 소멸자를 호출해줌
    + **스마트 포인터**를 통해 소멸될 때 자동으로 호출되게 할 수 있음

## 장점
+ 포인터
  + **동적 할당**이 가능함
  + **가리키는 대상의 변경**이 가능함
  + **함수의 인자 전달**
    + 주소만 복사해서 전달되기 때문에 불필요한 복사 연산을 줄임
  + **오브젝트 슬라이싱 방지**
    + 포인터나 참조가 아닌 일반 변수로 객체를 선언하고 업캐스팅 시에 오브젝트 슬라이싱 발생
+ 동적 할당
  + 동적으로 메모리를 할당하고 해제할 수 있기 때문에 **동적 배열** 등 효율적인 프로그래밍이 가능함

## 단점
+ 포인터
  + 복잡성이 증가하고 디버깅이 어려움
+ 동적할당
  + **생성과 해제에 대한 오버헤드**가 있음
  + **메모리 누수**와 **댕글링 포인터**를 조심해야함

## 예시
```cpp
// int 자료형
int* value = new int;
delete value;

// int 배열
int* arr = new int[size];
delete[] arr;

// int 2차원 배열
int** arr = new int*[row]
for(int i=0; i<row; i++)
{
  arr[i] = new int[col];
}
for(int i=0; i<row; i++)
{
  delete[] arr[i];
}
delete[] arr;
```

## 관련
+ **placement new**
  + 이미 할당된 메모리에 객체를 생성함
  + c언어의 동적할당을 사용할 때 생성자를 명시적으로 호출할 때 사용함

```cpp
FClass* A = (FClass*)malloc(sizeof(FClass));
new(A)FClass();
A->~FClass();
```
