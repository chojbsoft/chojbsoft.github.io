---
title: "[C++] 포인터, 동적 할당"
date: 2024-03-27
author: Tigger
categories: [C++]
tags: [포인터, 동적 할당, placement new]
---

## 개념 
+ 포인터
  + 주소를 저장하는 변수
+ 동적할당
  + 힙 영역에 메모리를 할당하고 주소를 반환함

## 특징
+ 포인터
  + **포인터 자체의 크기**는 플랫폼 bit 수에 대응해서 바뀜
  + 아무것도 가리키지 않는다는 의미로 nullptr를 사용
    + **0, NULL, nullptr 모두 같은 0**이지만 정수를 파라미터로 가진 오버로딩된 함수가 호출되는 경우를 방지하기 위해 nullptr를 사용
  + const 포인터
    + const 키워드가 애스터리스크 뒤에 있다면 주소가 상수화됨
    + const 키워드가 애스터리스크 앞에 있다면 역참조의 값이 상수화됨
    + 양쪽에 붙이면 둘 다 상수화됨
+ 동적할당
  + **new, new[]**로 할당
    + 메모리가 부족한 경우 동적 할당이 실패하여 nulptr를 리턴할 수도 있음
    + c언어의 malloc, calloc, realloc와는 다르게 생성자를 호출해줌
  + cpp에는 가비지컬렉션이 없기 때문에 **delete, delete[]**로 직접 해제
    + c언어의 free와는 다르게 소멸자를 호출해줌
    + **스마트 포인터**를 통해 소멸될 때 자동으로 호출되게 할 수 있음

## 장점
+ 포인터
  + **동적 할당**이 가능함
  + **함수의 인자 전달**
    + 주소만 복사해서 전달되기 때문에 불필요한 복사 연산을 줄임
  + 업캐스팅
    + 포인터 변수가 아닌 일반 변수로 객체를 선언하고 업캐스팅 시에 슬라이싱이 될 수 있음
      + **슬라이싱**이란 상속받은 하위 객체에서 추가로 정의한 속성들이 잘려 나가는 것
  + 배열 조회 효율
    + 배열을 포인터로 접근하는 것이 인덱스로 접근하는 것보다 빠름
    + 인덱스로 접근하면 이를 주소로 변환하는 작업이 추가적으로 있기 때문
  + 링크드리스트 기반 자료구조
    + 요소 간의 관계를 포인터로 표현하는 링크드리스트 자료구조를 구현할 수 있음
+ 동적 할당
  + 동적으로 메모리를 할당하고 해제할 수 있기 때문에 **동적 배열** 등 효율적인 프로그래밍이 가능함

## 단점
+ 포인터
  + 복잡성이 증가하고 디버깅이 어려움
+ 동적할당
  + **생성과 해제에 대한 오버헤드**가 있음
  + **메모리 누수**와 **댕글링 포인터**를 조심해야함

## 예시
```cpp
// int 자료형
int* value = new int;
delete value;

// int 배열
int* arr = new int[size];
delete[] arr;

// int 2차원 배열
int** arr = new int*[row]
for(int i=0; i<row; i++)
{
  arr[i] = new int[col];
}
for(int i=0; i<row; i++)
{
  delete[] arr[i];
}
delete[] arr;
```

## 관련
+ **placement new**
  + 이미 할당된 메모리에 객체를 생성함
  + c언어의 동적할당을 사용할 때 생성자 및 소멸자를 명시적으로 호출할 때 사용함

```cpp
FClass* A = (FClass*)malloc(sizeof(FClass));
new(A)FClass();
A->~FClass();
```
