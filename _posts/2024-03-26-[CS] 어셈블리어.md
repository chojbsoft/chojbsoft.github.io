---
title: "[CS] 어셈블리어"
date: 2024-03-26
author: Tigger
categories: [CS]
tags: [어셈블리어, ISA, CISC, RISC, x86, mov, lea]
---

## Summary
+ ISA를 사람들이 이해할 수 있게 번역한 중간언어
+ 대표적인 ISA로 인텔의 CISC기반인 x86, ARM의 RISC기반인 ARM이 있음
+ CISC: 명령어 셋이 복잡하여 전력 소모가 크고 메모리 효율이 좋음
+ RISC: 명령어 셋이 단순하여 전력 소모가 낮고 속도 효율이 좋음
+ 기계어와 1대1로 대응되기 때문에, CPU마다 문법이 다름
+ x86 어셈블리어의 lea는 메모리 접근 없이 주소만 로드

## Details
x86은 인텔의 32비트 CPU 아키텍처로 유명합니다.
사실은 인텔의 16비트 CPU 제품부터 x86 이름이 붙었지만, 32비트 CPU 제품의 인지도가 더 크기 때문에 x86은 어느덧 32비트 CPU의 고유명사 느낌이 되었습니다.

여기서 재밌는 사실은 32비트의 의미는 레지스터의 크기를 의미하고, 따라서 4GB 용량까지의 램만 인식할 수 있다는 것입니다.
메모리에 저장된 명령어를 실행하기 위해, 레지스터로 해당 메모리 주소를 로드해야합니다.
이 때 메모리 주소의 기본 단위는 1Byte이기 때문에, 2^32 * 1 Byte 즉 4GB 용량의 램까지 밖에 인식하지 못합니다.

어쨋든 이러한 32비트 CPU 아키텍처인 x86은 CISC 기반의 ISA입니다.
대표적인 x86의 어셈블리어로 mov, lea가 있습니다.
이를 알고 있다면 디스어셈블리 코드 볼때 유용할 것 같습니다.

mov 명령어는 x86 어셈블리어에서 가장 기본적이고 자주 사용되는 명령어 중 하나입니다. 
이 명령어는 우변의 값을 좌변에 복사하는 역할을 합니다. 
데이터의 이동을 수행하는데, 메모리와 레지스터 간의 데이터 전송에 주로 활용됩니다.
```
mov eax, 5      ; EAX 레지스터에 5를 저장
mov [esp], eax  ; esp 주소의 값에 EAX의 값을 저장
```

lea(Load Effective Address) 명령어는 우변의 계산된 주소를 좌변에 로드하는 역할을 합니다. 
이 명령어는 메모리 접근을 하지 않기 때문에, 복잡한 주소 계산이나 포인터 연산에 유용합니다. 
대괄호 표시는 값이 아닌 주소임을 의미합니다.
```
lea eax, [esp]  ; esp에 저장되어 있는 주소를 EAX 레지스터에 로드
```




